원문: https://aqueduct.io/docs/application/threading/

# Multi-threading in Aqueduct

Aqueduct과 다른 서버 프레임워크 간의 주요 차별화 요소 중 하나는 멀티 스레드 동작입니다. Aqueduct 응용 프로그램이 시작되면 여러 스레드에서 응용 프로그램 논리를 복제합니다.

Dart에서는 스레드를 * isolates *라고합니다. 네이밍의 차이점은 단순한 것만은 아닙니다. 격리는 메모리와 스레드간에 약간 다른 점이 있습니다. 각각의 isolate에는 다른 isolates가 액세스 할 수없는 자체 heap (여기에는 object에 대한 메모리가 할당 된 곳입니다)이 있습니다.

격리 된 스레드는 매우 유용합니다. 많은 멀티 스레드 응용 프로그램은 스레드간에 메모리를 공유하기 때문에 어려운 디자인 패턴이 필요하며 가장 숙련 된 프로그래머조차 어려움을 피할 수있는 버그를 쉽게 추적 할 수 있습니다.

## How Aqueduct Uses Isolates

어플리케이션은 `ApplicationChannel`에서 일련의 초기화 메소드를 호출하여 초기화됩니다. 일단이 메소드들이 실행을 끝내면, 어플리케이션은 `ApplicationChannel`에 의해 생성 된 채널을 통해 HTTP 요청을 보내기 시작합니다.

`ApplicationChannel`은 유형이고 인스턴스화 될 수 있기 때문에 - Aqueduct는 단순히 격리 된 수를 생성하고 각각에 대해 `ApplicationChannel`을 인스턴스화 합니다. 따라서 초기화 코드는 각각의 분리 알고리즘에 대해 동일합니다. 즉, 각 분리 알고리즘의 진행중인 동작도 동일 함을 의미합니다.

더욱 중요한 것은 프로그래머 인 여러분이 Aqueduct의 멀티 스레드 동작을 활용하는 데 아무 것도하지 않아야한다는 것입니다. 응용 프로그램을 실행할 분리 수를 선택하기 만하면됩니다 ([이 섹션](https://aqueduct.io/docs/application/threading/#how-many-isolates-should-i-use) 참조) ).

여러 개의 프로세서를 활용하려면 Aqueduct 응용 프로그램에서 아무 것도 할 필요가 없지만, 다른 방법으로해서는 안되는 일이 나해야 할 일이 있습니다.

첫째, 응용 프로그램의 상태를 유지해야합니다. 초기화 후에 요청을 처리하는 동안 생성 된 모든 객체는 요청이 완료되면 파기되어야 합니다. 지속되어야 하는 모든 데이터는 데이터베이스 또는 다른 데이터 저장소에 저장해야합니다. 이것은 REST API를 위한 좋은 연습 일 뿐이므로 여기서는 아무 것도 실제로 손실되지 않습니다.

그러나 상태를 추적해야 하는 경우가 있습니다. 예를 들어, websocket 연결을 관리하는 경우, 초기화 후 일부 상태 (websocket 참조)를 저장해야합니다. [이 가이드](https://aqueduct.io/docs/http/websockets/)에서이 주제를 자세히 다룹니다. 간단한 설명은`ApplicationMessageHub`를 사용하는 것입니다.

고려해야 할 중요한 또 다른 사항은 초기화입니다. `ApplicationChannel`에서 `prepare()`와`entryPoint()` 메소드는 각각의 격리에서 호출됩니다. 이 동작은 각 격리에 대해 발생하는 것으로 보장되며 자주 걱정할 필요가 거의 없습니다.

그러나, `ApplicationChannel.initializeApplication`을 구현할 때 코드는 주 격리에서 실행됩니다. 정적 변수 또는 싱글 톤에 대한 변경 사항은 응용 프로그램 논리를 실행하는 격리 항목으로 복제되지 않습니다. 이 메소드의 유스 케이스는 매우 적지 만,이 메소드에서는 `CodecRegistry`와 같은 유형을 구성하지 않는 것이 중요합니다.

## How Many Isolates Should I Use

`aqueduct serve`로 시작할 때 응용 프로그램의 기본 분리 수는 3입니다. 3 개 미만의 격리는 성능을 가장 확실하게 저하 시키지만, 3을 초과하면 성능이 반드시 향상되지는 않습니다. (그리고 더 많은 것들이 확실히 성능을 떨어 뜨릴 것입니다.)

격리 수 계산을 결정하는 많은 변수가 있습니다. 먼저, 컴퓨터가 기본적으로 두 가지 작업을 수행한다는 점을 상기하십시오. 지시 사항을 실행하고 데이터를 전송합니다. 이러한 작업은 특히 데이터가 수천 킬로미터 떨어진 다른 컴퓨터로 전송되는 경우 시간이 오래 걸립니다. (현대의 놀라운 점은 이러한 작업은 가능한 빨리 수행된다는 것입니다. 우리가 자주 당연하게 여기는 작업입니다.)

단일 요청을 처리하는 데 몇 밀리 초의 속도 차이가 의미있는 것은 아니지만 한 번에 수천 개의 요청을 받으면이 밀리 초가 합산됩니다. 응용 프로그램이 실행 지침을 따라 잡기 위해 애쓰고 있을 때 CPU 기반 *이라고합니다. (응용 프로그램이 데이터 전송에 어려움을 겪고있을 때 * IO-bound *라고합니다.)

CPU 바운드 응용 프로그램에는 두 가지 선택 사항이 있습니다. 명령어를 적게 실행하거나 명령을 실행하기 위해 더 많은 프로세서 (또는 코어)가 있어야합니다. 오늘날 대부분의 컴퓨터에는 다중 프로세서가 있습니다. 단 하나의 분리를 사용하는 경우, Aqueduct 응용 프로그램은 한 번에 하나의 프로세서 만 사용할 수 있습니다. 분리 수의 증가에 따라 한 번에 사용할 수있는 프로세서 수가 증가합니다.

따라서 더 많은 격리 알고리즘은 더 많은 프로세서가 더 많은 명령어를 의미하고 응용 프로그램이 CPU에 의해 덜 제한된다는 것을 의미합니다. 그러나 두 개의 프로세서 만있을 때 100 개의 격리를 생성하면 성능이 향상되지 않습니다. 단 하나의 프로세서에서 50 개의 격리가 처리되므로 한계가 있습니다. 실제로 이러한 지침을 예약하는 작업량과 많은 격리 된 메모리 양이 성능을 저하시킵니다.

예를 들어 내 4 코어 시스템에서 [wrk](https://github.com/wg/wrk)를 사용하여 벤치 마크를 실행하면 1에서 4까지의 격리를 추가하면 훨씬 좋은 결과를 얻을 수 있지만 그 다음에는 한계가 있습니다. 마지막으로 4보다 작거나 같음 성능을 나타냅니다. 파란색 막대는 Aqueduct에 간단한 HTTP 호출을 할 때 각 분리 수에 대한 초당 요청 수를 나타냅니다.

![Requests Per Second](https://aqueduct.io/docs/img/req_per_sec.png)

(벤치 마크는 애플리케이션의 상대적인 성능을 측정하고 병목 현상을 식별하는 좋은 방법이지만, 네트워크를 통한 실제 사용 성과 성능이 중요합니다. 이러한 벤치 마크의 절대 값은 완전히 제거되므로 심각하지 않아야합니다. 전송의 네트워크 부분.)

그러나 이것이 전체적인 이야기는 아닙니다. 서버 응용 프로그램은 거의 CPU 바운드가 아니라 IO 바운드입니다. 빨간색 막대는 데이터베이스 쿼리를 작성하고 해당 쿼리의 결과를 응답 본문의 JSON으로 반환 할 때 초당 요청 수를 나타냅니다. 관측소를 사용할 때 측정 결과는 압도적 인 대부분의 시간이 데이터를 데이터베이스와주고받는 데 소비된다는 것을 나타냅니다. 이것은 입출력 (및 쿼리 속도)에 의해 구속되는 예입니다.

각각의 격리 된 데이터베이스는 고유 한 데이터베이스 연결을 가지고 있음을 상기하십시오. 데이터베이스 연결은 직렬 대기열이며 한 번에 하나의 쿼리 만 처리 할 수 있습니다. 데이터베이스 연결 수를 늘리면 한 번에 더 많은 쿼리를 처리 할 수 있습니다. 이것은 데이터베이스 호출이 있거나없는 요청의 대기 시간을 측정하는 다음 그래프를 보는 것보다 더 분명하지 않습니다.

![Average Latency](https://aqueduct.io/docs/img/latency.png)

단 하나의 데이터베이스 연결 (하나의 격리)이있을 때 대기 시간은 요청 당 상당히 더 높습니다. 응용 프로그램은 데이터베이스 직렬 대기열의 속도에 완전히 묶여 있습니다. 두 번째 격리를 추가하고 두 번째 데이터베이스 연결을 추가하면 대기 시간이 절반 이상 감소합니다.

더 많은 데이터베이스 연결이 추가되면서 감소하는 수익이 있습니다. 이는 프로세서 당 스레드 수에 관한 동일한 사항이 데이터베이스 연결 수에 적용되기 때문입니다. 더 많은 데이터베이스 연결을 추가한다고 해서 데이터베이스 서버가 더 빨리 실행되는 것은 아닙니다.

일반적으로 N-1 격리로 시작하십시오. 여기서 N은 시스템의 프로세서 수입니다. `wrk`과 Observatory를 사용하여 응용 프로그램을 프로파일하고 그에 따라 조정하십시오. 다중 인스턴스 환경에서 데이터베이스 연결의 총 수는 MxN이며, 여기서 M은 시스템 수이고 N은 격리 수입니다.

입출력이 덜 격리 된 곳에서 더 나은 서비스를 제공하지만 CPU가 더 많은 격리 지점에 더 잘 서비스 될 수있는 잼을 발견하면 데이터베이스 연결 풀 분리를 사용하는 것이 좋습니다.