C/C++

# this 포인터

C++에서 객체내부에서 객체 자신을 가리킬 지시가 필요합니다. 이것을 `this` 포인터라고 합니다. 파이썬에서는 `self`라고도 합니다. `this`는 포인터이기 때문에 `this`는 포인터처럼 다뤄져야 합니다.

다음 예제를 보겠습니다.

```c++
#include <iostream>

class Foo
{
    int a = 10;
    
    int add(int a)
    {
        return a + a;
    }
}

void main()
{
    Foo f;
    int v = f.add(1);
    std::cout << v << std::endl;
}
```

이 코드를 실행하면 어떤 값이 표시될까요?

코드를 읽어 보겠습니다.

- 클래스 `Foo`의 멤버 변수 `a`는 `10`입니다.
- 멤버함수 `add()`의 파라미터는 `a`가 있습니다.
- `main`() 함수에서 `f.add()`에 `1`이 전달 되고 있습니다.

`add()` 리턴 값은 `1+1`일까요? `10+1`일까요? `1+10`일까요?

C++의 스코프 우선순위에 따라 파라미터나 로컬변수가 가장 우선순위를 가집니다.

따라서 `1+1`을 리턴하게 됩니다.

그런데 개발자의 의도는 파리미터 `1+1`을 하는게 아니라 멤버변수 `10 `과 파라미터 `1`을 더하고 싶습니다.

이때 명확하게 객체의 멤버변수라고 지정해 줄 수 있습니다.

`a + a`를  `this->a + a`로 지정하여 첫 `a`가 멤버변수임을 지정할 수 있습니다.

```c++
#include <iostream>

class Foo
{
    int a = 10;
    
    int add(int a)
    {
        return this->a + a;
    }
}

void main()
{
    Foo f;
    int v = f.add(1);
    std::cout << v << std::endl;
}
```

이 코드의 결과는 11이 될것입니다.

실제 개발에서 멤버변수와 같은 이름을 가진 파라미터 이름을 짓는 것은 좋지 않은 냄새입니다만, `this` 포인터를 통해 객체 자신을 가리킬 수 있다는 것을 보여주기 위해 예를 들어 보았습니다.



